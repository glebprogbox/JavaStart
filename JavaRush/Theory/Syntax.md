## Start
Ява универсальный язык, программа запускается в ява машине. После компиляции ява сохраняет программу в байт коде, а ява машина (JVM) этот код запускает.

Принципы:
- писать каждую команду с новой строки
- в конце команды ставится ;
- программа НЕ может состоять из команд, только из следующей схемы:

![image](https://github.com/user-attachments/assets/a73ceead-08d1-4ee9-8bc7-0e7e7a574758)

(классы - функции (методы) - команды)
Java программа всегда состоит из классов. Минимально в программе будет 1 класс и 1 метод.
Для каждого класса - свой файл с именем класса. Допустим, класс House, будет файл House.java. Внутри файла код.
Код класса состоит из: имени класса и тела класса. House.java может быть таким:
public class House
{
тело класса
}
Тело класса обычно (но необязательно) состоит из методов (функций) и переменных.

С метода main начинается любая программа. Он обычно всегда одного и того же вида:
public static void main (...)
{
код метода - какие-нибудь команды
}
Итого: класс - методы - команды и переменные

Пример команды. System.out.println("Привет мир!");
(большие или маленькие буквы в команде имеют значение!) Команда содержит параметр - строку Привет мир.

## Переменные

Аналогия - коробка для хранения данных.
Три свойства переменных:
- тип, что храним?
- имя, имя коробки
- значение, объект который храним
У объектов тоже может быть свой тип - число, строка и тп.
Объявление переменной:
тип имя
int a;
String s;
double c;
Можно объявлять списком int a,b,c,d;

В разных методах могут быть переменные с одним именем, но в одном методе - нет.
Буквы важны (a и A - разные переменные)

Присваивание (и инициализация):
int i;
i = 3;
x = i +1; (в итоге x = 4)
Можно сразу присваивать или инициализировать, int i = 3; int x = i +1;
Нельзя использовать переменную без инициализации;

y = x; (y тож будет 4)
имя = значение
присваивание копирует значение из одной переменной в другую
Важно - при сложении строк и чисел получается строка )) 

Можно так
int x=1; int y = 2; z = 3; итп
x = y = z;
тут справа налево работает, y =z будет y =3, потом x = y = 3; 

Для сравнения в Java используется ==
имя == значение
одна переменная == одно значение

## Комментарии
В ява вот так: // или /* ... */

## Всякое
% это остаток от деления
int A = 546 % 10; // тут будет 6 (потому что 54.6 остаток 6)
int A = 2%2; // тут будет 0  - так можно проверять четность чисел ))

!= не равно
>=
<=
>
<
=
==
+=
-=
*=
/=
%=

пример 
int x = 1;
int y = 2; 
можно использовать x +=y; итог x = x+y = 3

&& это И
...println(100>10 && 100>200); // итог false, тк все не тру, то есть проверяем все условия
|| это или
тогда в примере выше вернется тру, если использовать || вместо &&


## Инкремент
Прибавление на один выполняется так
a++; 
это тож самое что a=a+1;
декремент (уменьшение) будет a--; или a=a-1;
int x = 99;
int y=x++; // y = 99, а x станет 100, сначала идет основное выражение, потом инкремент !!!
но если 
int y=++x; // будет y =100, x = 100, тк сначала инкремент

## String
String - эт полноценный класс, у него есть методы, в отличие от int / double (например), поэтому с большой буквы
Все объекты могут быть преобразованы в тип String))
String A = "blabla"; 
String a = "1", b = "Vasya";
String A; // тут просто объявили

Конкатенация
String a = "vas" +"ya" + " " + "super" + b; 

Если int и String вместе, на выходе будет String.
НОО.. важно
int a = 5;
String = a + a +"1" +a ; // будет не 5515, а 1015
Идем слева направо:
((5+5)+"1")+5 = (int + string) + int = String 101 + int 5 = 1015

Переводим int в строку
int a = 5;
String stra = "1" + a; // будет стринг 15, ну или если просто "" + a то будет 5

Переводим string в int

String b = "1";
int x = Integer.parseInt(b); // класс.метод.(параметр), будет int 1

Методы стринг
String name = "Ro";
int count = name.length(); // будет int 2
или 
int count = "Ro".length(); // тож 2
int count = ("Ro" + 12 + name).length() // будет 6, тк 6 символов Ro12Ro

toLowerCase() - в маленькие буквы
String name2 = name.toLowerCase();
toUpperCase - в большие буквы

## Числа
Типы для хранения чисел
целые
byte - 1 байт
short - 2 байта
int - 4 байта
long - 8 байтов
не целые
float - 4 байта
double - 8 байтов
(вся работа с памятью идет только через JVM)

## Про булевое
boolean x = true; // true или false
...println(!x); // результат = фолс, противопоставление, ! меняет на обратное

## Scanner класс
Scanner console = new Scanner(System.in); // в качестве параметра передаем то, откуда будет брать данные сканнер
создаем объект типа сканнер, сохраняем ссылку на него в переменную console, дальше с ней работаем
String name = console.nextLine();
читаем строку текста с клавы
int age = console.nextInt();
читаем с клавы число

Для вызова объекта метода, на который ссылается переменная console, делаем вызов таким образом
переменная.метод(параметры)
В итоге вызываем метод объекта на который ссылается переменная.
System.out.println("HIHIHI"); // пример

У сканера еще куча методов, типа nextLong() или next() и тп
есть проверки, типа hasNextInt();
сканнер обязательно вычитывает данные по порядку




## Приведение типов
Хотя типы переменных в Java устанавливаются при инициализации и далее не меняются, есть возможность присваивать одной переменной тип иной переменной.
Присваивание другого типа может быть сужением или расширением - зависит от того, какой тип мы присваиваем. В итоге, присваивание произойдет гладко, если байт хватает, или какая-то часть данных будет утеряна.

Расширение:
Переменной большего размера всегда можно присваивать переменные меньшего размера (допустим, для long присваиваем int).
```
byte a = 5;
short b = a;
int c = a + b;
long d = c * c;
```
Вещественным типам (float и double) можно присвоить значение любого целочисленного типа. Но будет потеряна какая-то часть числа.
```
long a = 1234567890;
float b = a;
double c = a;
```

Сужение:
Тк часть данных потеряется, для компилятора явно указываем оператор преобразования типа - (тип) выражение
```
long a = 1000000;
int b = (int) a;
short c = (short) b;
byte d = (byte) c;
```
P.S. d = 64. Можно перевести в двоичную запись, откинуть байты и перевести обратно в десятичную. Будет 64.

Если присваивание идет нескольких типов, то в итоге все присваивание будет к бОльшему типу. И только потом начнется выражение. Например, int + byte + short будут приведены к int и только потом суммированы.

Если есть вещественные числа, то будет присваивание к их типу.

Если взаимодействуют типы byte char short, то они будут приведены к int. Важно учитывать при попытке применения результата выражения к типу, меньшему чем int. В таком случае понадобится оператор преобразования.

Оператор преобразования имеет высокий приоритет, поэтому если идет выражение с несколькими операциями и есть потенциальный конфликт приоритетов, ставим выражение в скобки.


## Ссылки переменные
В Java есть переменные примитивного типа, которые хранят сразу значение (целочисленное, вещественное или тру/фолс или закодированный символ). А есть переменные с ссылками на какой-нибудь объект.
Это, например, типы переменных массив и String, они хранят ссылку на объект.
При присваивании примитивной переменной копируется сам объект. А при присваивании ссылочной переменной копируется ссылка на объект.

Ссылки дают преимущество - объект не копируется лишний раз, а какой-нибудь метод сможет работать с этим объектом, если ему передать ссылку на объект.

Размер всех ссылок 4 байта. Исключение - если программа запущена на 64битной системе, размер будет 8 байт.

Ссылка может быть null (например, еще не объявили значение ссылки или вы сами присвоили null чтобы затереть ссылку).

При передаче переменных ссылок в методы, метод возьмет ссылки на объекты и начнет с ними работать. То есть входным переменным присваивается ссылка переданных переменных.

## Объекты
Почти все в Java это объекты, за исключением некоторых штук, например примитивные переменные это не объекты.
Объект - сгруппированная сущность данных (переменных) и методов, для того, чтобы работать с этими данными. Переменные объекта еще называют данные или состояние объекта.
Методы объекта обычно называют поведением объекта. Менять переменные объекта не через методы объекта - плохой тон))
У каждого объекта есть тип, определяется один раз и изменять нельзя. Типом объекта считается его класс.
У каждого объекта также есть копия переменных класса (полей класса). Если в классе изменили нестатик переменную, и программа создала несколько объектов этого класса, в каждом объекте будет собственная эта переменная.

Чтобы работать с объектом - сохраняем ссылку на объект в переменную, а потом вызываем методы у этой переменной.
переменная.метод(); -- переменная хранит ссылку на объект, а метод - это метод класса объекта.
Чтобы обратиться к переменной объекта - используем переменная.поле;
Переменная - хранит ссылку на объект, а поле - это переменная класса (поле объекта).

Создание объекта:
Класс переменная = new Класс(параметры);
В переменной будет ссылка на объект.
```
Scanner console = new Scanner(System.in);
int x = console.nextInt();
```
В примере выше создаем переменную типа (класса) Scanner, которая будет содержать ссылку на новый (new) объект типа Scanner, с параметром System.in. Во второй строке вызывается метод нашего нового объекта и значение присваивается переменной x.
```
String s = new String("Привет");
```
Это тоже объект))
```
int[] data = new int[10];
```
И это))

По итогу - созданный объект = объект или экземпляр класса (с определенным типом, тип = класс).
Если упрощать - объект это область памяти, которая содержит переменные (поля), объявленные в классе. То есть это группа переменных определенного класса.

## Классы
Использовать классы других удобно, но когда создавать свои? Обычно тогда, когда нужно создать новую сущность в своей программе.
Удобно создавать класс и объект, чтобы сразу хранить несколько переменных вместе. Пример - надо хранить и показывать координаты x и y (массивом). По джуновски мы бы объявили их в классе отдельно и далее показаывали их, например, вот так:
```
System.out.println("x = " + x + ", а y = " + y + ".");
```
Как иначе? Создаем класс Coordinate
```
public class Coordinate
{
    public int x;
    public int y;
}
```
В основном методе прописываем создание объектов и выводим на экран отдельным методом
```
class Program //основной класс
{
public static void main(String[] args)
{
    Coordinate[] point = new Coordinate[10];
    for(int i = 0; i<point.length; i++)
    {
        point[i]=new Point();
    }
    printCoordinate(point);
}
public static void printCoordinate(Coordinate[] point) //Делаем метод для вывода координат на экран
{
    for(int i = 0; i<point.length; i++)
    {
        System.out.println("х = " + point[i].x + ", а y = " + point[i].y + ".")
    }
}
}
```
Что произошло? Объявили класс Координейт и основной класс, создали массив объектов (10 шт) класса Координейт (ака создали объекты с типом Координейт), выделили память, грубо говоря. Далее каждому элементу создаем объект с типом поинт, и потом выводим с помощью функции принтКоординейт.

## Mutable и Immutable объекты
Имутебл объекты - это объекты-константы, которые нельзя менять.
Пример - объект String. Метод, например, toUpperCase будет создавать новый объект.
```
String text = "Это очень важное сообщение";
String message = text.toUpperCase();
```
Тут в мессаже будет новый объект ЭТО ОЧЕНЬ ВАЖНОЕ СООБЩЕНИЕ.
Как добились того, что Стринги нельзя менять?
- все переменные класса стринг скрыты, private
- наследоваться от класса стринг нельзя, там модификатор final
- все методы класса возвращают новый объект
Можно смело передавать строки в любые методы, их не поменяют.


## ООП
Из-за того что функций оч много, как и данных, их начали объединять в объекты - данные (переменные) + методы (функции).
Оставался вопрос - какие функции должны быть внутри объекта, а какие между объектами.
В итоге выработали 4 принципа объектно-ориентировааного программирования:
абстракция, инкапсуляция, наследование и полиморфизм.

Абстракция - использование только тех характеристик объекта, которые представляют объект максимально (достаточно) точно для решаемой задачи, те используем минимально нужное количество полей и методой для объекта.
В Java абстракция осуществляется через использование абстрактных классов и интерфейсов. Абстракция – отвлечение от целостности объекта и выделение его главных свойств и составляющих, нужных нам. Пример - раскидывание должностей и обязанностей, можно сделать одного директора, а можно финансового, генерального и технического.
Грубо говоря, абстракция - правильное разделение программы на объекты.
Абстракция помогает выделять нужные, главные, характеристики объекта и отбрасывать второстепенные.

Инкапсуляция - улучшает качество взаимодействия элементов за счет их упрощения, а именно - скрывает сложное и лишнее от посторонних глаз (сокрытие реализации). Другими словами, используем грамотно модификатор private для методов и переменных и для взаимодействия оставляем только нужные данные и методы с public.

Наследование - специальное отношение между двумя классами. Позволяет создавать новую вещь, класс, не с нуля, а на основе существующего класса.
Можно создавать класс на основе другого, тогда класс будет потомком (наследником) другого, существующего класса. То есть если в классе есть уже нужные методы и данные, просто создаем наследника. Просто объявляем нужный класс родителем своего нового класса и готово - в новом классе автоматически будут все данные и методы класса-родителя.

Полиформизм - за одним интерфейсом могут скрываться разные реализации. Пример - человек может управлять машиной, значит может управлять и седаном, и хэтчбеком, и бмв, и мерседесом. Машины разные, реализация разная, но интерфейс один. Полиформизм позволяет единообразно обращаться к объектам различных классов (обычно имеющих одного родителя).
Пример
```
public class Animal {

   public void voice() {

       System.out.println("Голос!");
   }
}

public class Dog extends Animal {


   @Override
   public void voice() {
       System.out.println("Гав-гав!");
   }
}

public class Cat extends Animal {

   @Override
   public void voice() {
       System.out.println("Мяу!");
   }
}

и 

public class Main {

   public static void main(String[] args) {

       Animal dog = new Dog();
       dog.voice();
   }
}
```
Какой будет голос? Голос собаки)) тк мы переопределили метод аннотацией Override, а если нужна будет кошка, то создаем ссылку на объект кошки, new Cat. Родительский класс один, обращаемся одинаково, но поведение разное.
Еще Пример
```
public class AnimalBarbershop {

   public void shear(Animal animal) {

       System.out.println("Стрижка готова!");
   }
}

И теперь мы можем передавать в метод shear и объекты Cat, и объекты Dog!

public static void main(String[] args) {

   Cat cat = new Cat();
   Dog dog = new Dog();

   AnimalBarbershop barbershop = new AnimalBarbershop();

   barbershop.shear(cat);
   barbershop.shear(dog);
}
```
В итоге класс AnimalBarbershop работает с типами кэт и дог так, будто это один и тот же тип. Хотя животные ведут себя по-разному, подают разный голос. 


Внутреннюю структуру программы нужно поддерживать правильно с помощью принципов ООП, проще говоря, так, чтобы всегда можно было вносить изменения без проблем. Потому что каждый продукт должен развиваться.
Хорошо программу делить на слои/группы, в каждом слое свои объекты. В слое объекты сильно связаны, а между объектами разных слоев сохраняем слабую связность.
https://www.geeksforgeeks.org/coupling-in-java/
А на какие части делить программу, и как части взаимодействуют, исследуем с помощью принципа асбтракции. Еще инкапсуляцией прикрыть внутреннюю реализацию и готово -!) 

Про наследование
используем слово extends, получается так:
class Потомок extends Родитель
Наследоваться можно только от одного класса! Но можно выстроить цепочку наследования. Например, дом - машина - компьютер - телефон - часы.
Если класс не указан, то есть нет родителя, то таковым считается класс Object.
https://voron-vp.livejournal.com/42033.html - посмеяться


## Пакеты и классы
Чтобы не путаться в тысячи классов, придуманы пакеты (package)
Наименование формируется просто:
Путь к файлу - \com\java\super\one\Mega.java
имя пакета будет - com.java.super.one
имя класса будет - Mega
Хранят программу и пакеты обычно в одной папке, scr (сокращ от sorce)
Это корень проекта
Пакет не учитывает scr в имени
Пакетам и классам нужно давать читабельные имена, чтобы не было путаницы

Согласно стандарту Java в файле должен быть записан пакет и имя класса:
```
package com.java.super.one;

public class Service
{

}
```
Не писать package можно тогда, когда класс лежит напрямую в scr;
Полное имя класса = пакет + класс, всегда должно быть уникально в рамках одного проекта!

Импорт классов
Чтобы использовать в коде короткое имя класса, Mega, надо сначала импортировать класс
import com.java.super.one.Mega;
Импорт добавляем после package;
Если есть два класса с одинаковым коротким именем, то второй импортировать не получится, придется всегда указывать его длинное имя для использования
```
public class com.java.super.one.Mega {
}
```
Есть ленивый импорт, чтобы использовать все из нужного пакета
import com.*;
Все классы пакета java.lang импортированы изначально, импортировать повторно их не надо.

## Паузы
Thread.sleep(1000); - время указывается в мс, программа "уснет" на 1 сек
Важно учитывать время действия, если необходимо
Thread.sleep(1, 500_000); - уснет на 1 миллисекунду и 0,5 миллисек (указываются милисек и наносек).
Есть еще класс TimeUnit
TimeUnit.HOURS.sleep(15) - он просто удобнее, заснем на 15 ч, можно указать DAYS, SECONDS, MINUTES и тп.


## Литералы
Захардкоженные числа или значения строк
int x = 5; 5 - Литерал
String S = "sum5"; - sum5 - Литерал
Чтобы задать long литерал, надо в конце добавить l или L
Можно указывать литералы (числа) через _, это ни на что не повлияет
int x = 300_400_444; = 300400444
Вещественные - изначально double, чтобы был тип float, в конце добавляем f
или D для double


## Кодировки
Десятичная - стандартно
Двоичная - ставим перед числом 0
Шестнадцатеричная - ставим перед числом 0x
1 = в двоичной 0b0000001 = в шестнадцатеричной 0x1

## Экранирование
Обратный слеш позволяет экранировать символы (\)
\n - перенос строки
\t - символ табуляции (аналог tab)
\b - удаление посл символа, аналог бэкспейс
\r - возврат каретки
\" - двойная кавычка
\\ - будет просто слеш \

В Java используется Unicode кодировка, а именно UTF-16
\00A9 = символ копирайтинга
Если символов не хватает, то кодируют символ двумя выражениями в char
`System.out.println("\uD83D\uDD0A"); = 🔊`

## Про String
Это единственный класс, кроме примитивных типов, где литералы можно использовать в swith
Методы (полезные):
int length() - кол-во символов
boolean isEmpty() - проверка на пустоту
boolean isBlank() - проверяет, что в строке только пустые символы (пробел, энтер, таб)
char charAt(int index) - возвращает символ, стоящий на index позиции
char[] toCharArray() - возвращает массив символов (копию), из которых состоит строка
byte[] getBytes() - преобразует строку в набор байт и возвращает массив байт
String[] split(String regex) - разделяет строку на несколько подстрок
String join(CharSequence delimiter, elements) - склеивает вместе несколько подстрок
String intern() - помещает строку в пул StringPool

и про сравнение
boolean equals(String str) - сравнение строк
boolean equalsIgnoreCase(String str) - сравнение, игнорируя регистр
int compareTo(String str) - лексикографическое сравнение, число больше нуля, если текущая строка больше строки-параметра
int compareToIgnoreCase(String str) - также лексикографическое сравнение, игнорируя регистр, тоже вернет 0 если строки равны
boolean regionMatches(int toffset, String str, int offset, int len) - сравнивает части строк
boolean startsWith(String prefix) - проверяет, то строка начинается с prefix
boolean endsWith(String suffix) - проверяет, что текущая строка заканчивается на строку suffix

и про поиск
int indexOf(String str) - поиск строки в строке, вернется индес первого символа встретившейся строки
int indexOf(String str, int index) - поиск с пропуском, начнет искать с указанного индекса
int lastIndexOf(String str) - ищет с конца
вернет индекс первого вхождения
int lastIndexOf(String str, int index) - с конца с пропуском индекса первых символов
boolean matches(String regex) - проверяет, что строка совпадает с указанным регулярным выражением 

и про получение подстрок
String substring(int beginIndex, int endIndex) - вернет строку заданную интервалами (индексами), end не входит в интервал, его можно и не указывать, если не нужно
String repeat(int count) - повторяет строку N раз
String replace(char oldChar, char newChar) - возвращает новую строку, заменяя символ олдчар на символ ньючар, например точку можно заменить на двоеточие
String replaceFirst(String regex, String replacement) - заменяет в текущей строке подстроку, совпадающую с регуляркой, меняет только первое вхождение
String replaceAll(String regex, String replacement) - заменяет в текущей строке все подстроки, совпадающие с регуляркой
String toLowerCase() - преобразует строку к нижнему регистру
String toUpperCase() - преобразует строку к верхнему регистру
String trim() - удаляет все пробелы в начале и конце строки

и еще классы
String[] strings = str.split("ne"); - разбиваем строку, 
из Good news everyone! получится ["Good ", "ws everyo", "!"]
StringTokenizer - специальный класс для разделения строк
Состоит из конструктора и двух основных методов
В конструктор надо передать строку, которую мы разбиваем на части, и строку, используемую для разделения (набор символов)
String nextToken() - возвращает следующую строку
boolean hasMoreTokens() - проверяет, есть ли еще подстроки
StringTokenizer имя = new StringTokenizer(строка, разделители); - создание объекта
countTokens - показывает сколько токенов осталось (если сразу применить, покажет сколько всего строк)
в циклах при чтении токенов УМЕНЬШАЕТСЯ)
format() - позволяет задать шаблон объединения для строки с данными
`String имя = String.format(шаблон, параметры);`
`String.format("Age=%d, Name=%s", age, name); - d это подставить число, а s подставить строку. f - вещественное число, b - boolean, c - char, t - date`
`String s = String.format("a=%d, b=%d, c=%d", 1, 4, 3); s будет равна "a=1, b=4, c=3"`
можно указывать порядок
`String s = String.format("a=%3$d, b=%2$d, c=%d", 11, 12, 13); s будет равна "a=13, b=12, c=11"`

String pool
Используется для хранения литералов типа строка, это хранилище содержит строки и если задавать одну и ту же строку, то создается не новый объект в пуле строк, а просто выдается ссылка на существующий объект. Код хранится отдельно от данных.
```
String a = "Привет";
String b = "Привет";
String c = "Пока";
String[] pool = {"Привет", "Пока"};
a = pool[0];
b = pool[0];
c = pool[1];
```

а и б тут содержат одинаковые ссылки.
Чтобы добавить в стрингпул объект, есть метод intern()
```
String a = new String("Привет");
String b = new String("Привет");
```

тут разные объекты будут, тк стоит new

```
String a = new String("Привет");
String b = new String("Привет");
String t1 = a.intern();
String t2 = b.intern();
System.out.println(a == b); - фолс
System.out.println(t1 == t2); - тру
```

сравнение через intern() работает быстрее, чем через equals, тк сравнение не посимвольное, а просто ссылку сравниваем.

Строки в java - неизменяемые объекты (иммутабельные).
Но все же есть тип стринги, где можно менять строку. Это StringBuilder.

StringBuilder имя = new StringBuilder(строка); - создание бьюлдера на основе существующей строки
StringBuilder имя = new StringBuilder(); - создание пустого бьюлдера (пустая изменяемая строка)
методы:
append(obj) - преобразовывает объект в строку и добавляет к текущей строке
insert(int index, obj) - преобразовывает объект в строку и вставляет в текущую строку
replace(int start, int end, String str) - заменяет часть строки , заданную интервалом
deleteCharAt(int index) - удалить символ с определенным индексом
delete(int start, int end) - удаляет из строки символы, заданные интервалом
indexOf(String str, int index) - поиск подстроки в текущей строке
lastIndexOf(String str, int index) - тож самое но ищет с конца
charAt(int index) - возвращает символ строки по его индексу
substring(int start, int end) - возвращает подстроку, заданную интервалом
reverse() - переворачивает строку (задом наперед)
setCharAt(int index, char) - изменяет символ строки на другой по индексу
length() - возвращает длину строки
StringBuffer - аналог бьюлдера, только есть модификатор synchronized, значит можно обращаться из нескольких потоков. Позже разберемся. 

## Про объекты и конструкторы
Создание выглядит так - new Класс(параметры)
Создание и помещение ссылки на объект выглядит так - Класс имя = new Класс(параметры)
Часто переменную называют тем же именем, что и класс, но с маленькой буквы
PersonInfo personInfo = new PersonInfo()

Про конструктор
Выглядит так:
```
модификаторы Класс(параметры)
{
   код
}
```

имя метода-конструктора совпадает с именем его класса (и начинается с большой буквы)
метод-конструктор не имеет типа возвращаемого результата.
```
public class Point
{
   public int x;
   public int y;

   Point(int x, int y) //конструктор класса Point, с помощью this решаем конфликт имен, хотя могли назвать переменные по-другому
   {
      this.x = x;
      this.y = y;
   }
}
```

далее создаем объект и вызываем конструктор, чтобы установить стандартные значения
```
public class Solution
{
   public static void main(String[] args)
   {
      Point point = new Point(5, 10);
   }
}
```

Если задали определенный конструктор, то уже создать объект просто типа new Point(); нельзя, будет ошибка компиляции
Но можно сделать несколько конструкторов, исходя из параметров программа сама выберет нужный конструктор
```
class Cat
{
   public static final int UNKNOWN = -1;
   public String name;
   public int age;

   public Cat(String name, int age)
   {
      this.name = name;
      this.age = age;
   }
   public Cat(String name)
   {
      this.name = name;
      this.age = UNKNOWN; // неизвестно
   }
}
```

или
```
class Cat
{
   public static final int UNKNOWN = -1;
   public String name;
   public int age;

   public Cat(String name, int age)
   {
      this.name = name;
      this.age = age;
   }

   public Cat()
   {
      this.name = "Безымянный";
      this.age = UNKNOWN; // неизвестно
   }
}
```

Если не добавили ни один конструктор, то будет добавлен конструктор public по умолчанию, без параметров
Теоретически можно перезатирать значения
```
class Cat
{
   public String name;
   public int age = -1;

   public Cat(String name, int age)
   {
     this.name = name;
     this.age = age;
   }

   public Cat()
   {
     this.name = "Безымянный";
   }
}
```

здесь -1 перезатрется поданным значением Cat("one",3) - будет 3
- Создается объект типа Cat
- Инициализируются все переменные класса своими стартовыми значениями
- Вызывается конструктор и выполняется его код.
Т.е. переменные класса сначала инициализируются своими значениями, а уже затем выполняется код конструкторов.
Также переменные в классе инициализируются по порядку, обозначенном в классе.
Если создаем переменную внутри метода, то не можем ее использовать, если прежде не присвоили ей какое-нибудь значение. А с переменными класса иначе. Если переменной класса не присвоено стартовое значение, значит ей присваивается значение по умолчанию (для инт это ноль).
Про инициализацию констант - можно не присваивать значение в классе, если в каждом конструкторе константе присваивается значение.
- в конструктор не стоит пихать сложный код и логику, тк возможны ошибки
- если конструктор класса может выбросить checked-исключения (содержит ключевое слово throws), то обязательно нужно перехватить это исключение в методе, который создает объект.
```
class Solution
{
   public FilePrinter reader = new FilePrinter("c:\\readme.txt");
}
```

Такое не будет скомилировано(( тк конструктор класса FilePrinter содержит checked-исключения: вы не можете создать объект FilePrinter, не обернув его в try-catch. А try-catch можно писать только в методе
Небольшое отступление
Конструктор вызывается параметрами нового объекта ...new Banana(50, "nice"), а методы с параметрами вызываются так - banana.buy(50, "nice);
Инициализация идет так:
- переменные класса родителя
- конструкторы класса родителя
- переменные 
- конструкторы
```
ParentClass.a
ParentClass.b
ParentClass.constructor
ChildClass.c
ChildClass.d
ChildClass.constructor
```
Как передать параметр конструктору базового класса?
`super(param) или super(param1, param2, param3)`


## Нюансы объектов
Геттеры и сеттеры
Чтобы не было путаницы с полями класса для всех программистов, все поля класса делают private
Для того, чтобы только методы класса могли менять переменные класса, и никакие методы из других классов не имели доступа к переменным класса напрямую
Чтобы другие могли менять объекты внутри класса, надо добавить геттеры и сеттеры.
```
class Person
{
   private String name;

   public Person(String name)
   {
      this.name = name; 
   }

   public String getName()
   {
      return name;
   }

   public void setName(String name)
   {
      this.name = name;
   }
}
```
Никакой другой класс не сможет изменить значение поля name напрямую. Если кому-то нужно получить значение поля name, ему придется вызвать метод getName() у объекта типа Person. Если какой-то код хочет поменять значение поля name, ему нужно будет вызвать метод setName() у объекта типа Person.

## Удаление объектов
В Java сама ява занимается сборкой мусора (garbage collecting. сокращенно GC)
Все объекты сборщик мусора делит на достижимые и недостижимые. Если на объект есть хотя бы одна ссылка, он считается достижимым. Если нет ни одной переменной, которая ссылается на объект, такой объект считается недостижимым и объявляется мусором: значит, его можно удалять.
В Java нельзя взять и создать ссылку на существующий объект: ее можно только присвоить. Если мы стерли все ссылки на объект, он утерян навсегда.
Сначала в список достижимых добавляются те объекты, которые 100% живые. Например, текущий поток (Thread.current()) или Консоль (System.in).
Затем список достижимых объектов пополняют те, на которые ссылаются первые достижимые объекты. Затем те, на кого ссылаются вторые и т.д.
Таким образом, если есть некая группа объектов, которые ссылаются только друг на друга, но от достижимых объектов до них никак добраться нельзя, такие объекты будут считаться мусором и будут удалены.
Также ява сама занимается фрагментацией. Мы создали объекты - часть из них удалили - появились дыры. Ява все объекты держала в первой половине памяти. Далее она переносит объекты уже без дыр во вторую половину памяти, а первая будет чистенькой. Вот такие дела.

## Сравнение объектов
Объекты можно сравнивать по ссылке или по значению.
Если переменные ссылаются на один объект (==), то они равны.
Для сравнения значения надо использовать equals, он есть не только у Стринги, но и у всех классов. Почему? Все классы в Java считаются унаследованными от класса Object. А значит в классе-наследнике появляются все методы класса Object))). Среди таких методов есть методы, которые имеют отношение к сравнению объектов. Это метод equals() и метод hashCode().
Те мы просто пишем
```
class Person
{
   String name;
   int age;
}
```
То на самом деле выглядит это больше, например так:
```
class Person extends Object
{
   String name;
   int age;

   public boolean equals(Object obj)
   {
      return this == obj;
   }

   public int hashCode()
   {
      return адрес_объекта_в_памяти;         //это дефолтная реализация, но может быть и другая
   }
}
```
boolean equals(Object obj) - сравнивает текущий объект и переданный
int hashCode() - возвращает хэш код переданного объекта
Можно сравнивать объекты разных типов!) И это будет работать.
Integer a = 5;
String s = "Привет";
System.out.println(a.equals(s)); - фолс
System.out.println(s.equals(a)); - фолс
Equals сравнивает ссылки на объекты. Однако у стринги он сравнивает посимвольно текст. Потому что ребята переопределили работу этого метода для стринги. Можно и самому переопределить метод для нужных типов (классов).
Вне зависимости от того, для какого класса переопределять метод equals, он всегда принимает параметр типа Object.
instanceof - позволяет проверять какого типа объект
```
 if (!(obj instanceof Person))
      return false;
```
В переводе - если объект не типа Персон, вернуть фолс
```
Person person = (Person) obj; - операция приведения типа (разбирали выше)
```
Пример переопределения есть в файле "объекты.java".
Чтобы сравнить поля объекта, в том числе и null, используем Object.iphone(this.model, iphone.model); Но this тут избыточно, можно убрать, просто (model, iphone.model)

Про hashCode(); - выполняет неточное но быстрое сравнение
если его вызвать у объекта, то он вернет некое число — аналог первой буквы в слове. Это число обладает такими свойствами:
У одинаковых объектов всегда одинаковые hash-code
У разных объектов могут быть одинаковые hash-code, а могут быть разные
Если у объектов разные hash-code, объекты точно разные
Для большего понимания перепишем эти свойства относительно слов:
У одинаковых слов всегда одинаковые первые буквы
У разных слов могут быть одинаковые первые буквы, а могут быть и разные
Если у слов разные первые буквы, слова точно разные
Используем так - если хэш код одинаковый, есть смысл сравнивать, а если разный - нет смысла сравнивать вообще.
